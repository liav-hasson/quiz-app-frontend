pipeline {
    agent {
        kubernetes {
            cloud 'quiz-app-eks'
            yaml '''
                apiVersion: v1
                kind: Pod
                metadata:
                  name: agent-2
                  labels:
                    jenkins/label: agent-2
                spec:
                  containers:
                    - name: jnlp
                      image: liavvv/jenkins-agent-front:1.3
                      imagePullPolicy: Always
                      volumeMounts:
                        - name: workspace-volume
                          mountPath: /home/jenkins/agent
                        - name: docker-config
                          mountPath: /home/jenkins/.docker
                          readOnly: true
                  volumes:
                    - name: workspace-volume
                      emptyDir: {}
                    - name: docker-config
                      secret:
                        secretName: docker-config
                        items:
                        - key: config.json
                          path: config.json
            '''
        }
    }

    environment {
        BUILD_TAG             = "${BUILD_TIMESTAMP}"
        
        // Generates DOCKERHUB_CREDENTIALS_USR, DOCKERHUB_CREDENTIALS_PSW
        DOCKERHUB_CREDENTIALS = credentials('dockerhub-credentials')
        
        // Used for GitHub repository access (clone, push to GitOps repo)
        // Generates GITHUB_CREDENTIALS_USR, GITHUB_CREDENTIALS_PSW
        GITHUB_CREDENTIALS    = credentials('github-credentials')
        
        // Used for GitHub API calls (commit status updates)
        // This is a GitHub Personal Access Token with repo scope
        GITHUB_TOKEN          = credentials('github-token')
        
        // GitOps Configuration
        // GitHub repository for this application
        GITHUB_REPO           = "liav-hasson/quiz-app-frontend"
        GITHUB_REPO_URL       = "https://github.com/${GITHUB_REPO}.git"
        
        // GitOps repository (Helm charts)
        GITOPS_REPO_URL       = "https://github.com/liav-hasson/quiz-app-gitops.git"
        
        // Git configuration for commits
        GIT_USER_NAME         = "Jenkins Pipeline"
        GIT_USER_EMAIL        = "jenkins@weatherlabs.org"

        // Frontend project directory relative to repo root
        APP_DIR               = "react-app"

        // Docker image name without registry/user prefix (application)
        DOCKER_IMAGE_NAME     = "quiz-app-front"

        // CI resources directory
        CI_DIR                = "ci"
    }

    stages {
        stage('Prepare image version') {
            steps {
                script {
                    echo '--------- Preparing image version ---------'
                    checkout scm

                    // Determine environment based on branch
                    if (env.BRANCH_NAME == 'main') {
                        env.DEPLOY_ENV = 'prod'
                        echo "Building for PRODUCTION (main branch)"
                    } else {
                        env.DEPLOY_ENV = 'dev'
                        echo "Building for DEVELOPMENT (${env.BRANCH_NAME} branch)"
                    }

                    def semver = sh(returnStdout: true, script: './scripts/compute_next_version.sh . auto').trim()
                    if (semver) {
                        echo "Computed semantic version: ${semver}"
                        // Add -dev suffix for non-main branches
                        if (env.DEPLOY_ENV == 'dev') {
                            env.IMAGE_TAG = "${semver}-dev"
                            echo "Added -dev suffix for dev environment"
                        } else {
                            env.IMAGE_TAG = semver
                        }
                    } else {
                        echo "No semantic version computed; falling back to date-based tag: ${env.BUILD_TAG}"
                        if (env.DEPLOY_ENV == 'dev') {
                            env.IMAGE_TAG = "${env.BUILD_TAG}-dev"
                        } else {
                            env.IMAGE_TAG = env.BUILD_TAG
                        }
                    }
                    
                    echo "Final image tag: ${env.IMAGE_TAG}"
                    echo "Deploy environment: ${env.DEPLOY_ENV}"
                }
            }
        }

        stage('Install & Build') {
            steps {
                echo '--------- Installing dependencies and building frontend ---------'
                sh """
                    set -e
                    cd ${env.APP_DIR}
                    if [ -f package-lock.json ]; then
                        npm ci
                    else
                        echo 'package-lock.json missing; falling back to npm install'
                        npm install
                    fi
                    npm run build
                """

                echo '--------- Running dependency vulnerability scan ---------'
                sh """
                    set -e
                    cd ${env.APP_DIR}
                    npm audit --production
                """
                echo 'Dependency vulnerability scan passed!'
            }
        }

        stage('Dockerfile Security Scan') {
            steps {
                echo '--------- Running Dockerfile security scan ---------'
                sh '''
                    # Run Hadolint security scan on Dockerfile
                    # Check for security issues, best practices, and compliance
                    echo "Scanning Dockerfile with Hadolint..."
                    hadolint --format json ${CI_DIR}/app-dockerfile/Dockerfile > hadolint-report.json || HADOLINT_EXIT_CODE=$?
                    
                    # Display results in human-readable format
                    echo "Hadolint scan results:"
                    hadolint ${CI_DIR}/app-dockerfile/Dockerfile || true
                    
                    # Check if critical/error level issues found
                    if [ "${HADOLINT_EXIT_CODE:-0}" -ne 0 ]; then
                        echo "CRITICAL: Dockerfile security issues found!"
                        echo "Pipeline failed due to Dockerfile security violations"
                        echo "Fix the issues above and retry the build"
                        exit 1
                    fi
                '''
                echo 'Dockerfile security scan passed!'
            }
            post {
                always {
                    // Archive the Hadolint report for review
                    archiveArtifacts artifacts: 'hadolint-report.json', allowEmptyArchive: true
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    echo '--------- Fetching Google Client ID from SSM Parameter Store ---------'
                    
                    // Fetch Google Client ID from SSM Parameter Store
                    def googleClientId = sh(returnStdout: true, script: '''
                        aws ssm get-parameter \
                            --name "/devops-quiz/frontend/google-client-id" \
                            --region eu-north-1 \
                            --query "Parameter.Value" \
                            --output text
                    ''').trim()
                    
                    echo "Google Client ID fetched successfully"
                    
                    sh """
                        echo "Connecting to BuildKit DaemonSet..."
                        export BUILDKIT_HOST=tcp://buildkitd.jenkins.svc.cluster.local:1234

                        echo "Building ${DOCKERHUB_CREDENTIALS_USR}/${DOCKER_IMAGE_NAME}:${IMAGE_TAG} with buildctl..."
                        buildctl --addr \${BUILDKIT_HOST} build \\
                            --frontend dockerfile.v0 \\
                            --local context=${APP_DIR} \\
                            --local dockerfile=${CI_DIR}/app-dockerfile \\
                            --opt build-arg:VITE_GOOGLE_CLIENT_ID=${googleClientId} \\
                            --output type=image,name=${DOCKERHUB_CREDENTIALS_USR}/${DOCKER_IMAGE_NAME}:${IMAGE_TAG},push=true

                        echo "Image ${DOCKERHUB_CREDENTIALS_USR}/${DOCKER_IMAGE_NAME}:${IMAGE_TAG} built and pushed"
                    """
                }
            }
        }

        stage('Update GitOps Repository') {
            steps {
                echo '--------- Updating GitOps Repository ---------'
                script {
                    withCredentials([usernamePassword(credentialsId: 'github-credentials', 
                                                      usernameVariable: 'GIT_USERNAME', 
                                                      passwordVariable: 'GIT_PASSWORD')]) {
                        sh '''
                            ./scripts/update-gitops.sh \
                                "${DOCKERHUB_CREDENTIALS_USR}" \
                                "${DOCKER_IMAGE_NAME}" \
                                "${IMAGE_TAG}" \
                                "${BUILD_NUMBER}" \
                                "${GITOPS_REPO_URL}" \
                                "${GIT_USER_NAME}" \
                                "${GIT_USER_EMAIL}" \
                                "${GIT_USERNAME}" \
                                "${GIT_PASSWORD}" \
                                "${DEPLOY_ENV}"
                        '''
                    }
                }
            }
            post {
                success {
                    echo "✅ GitOps repository updated successfully"
                    echo "Environment: ${env.DEPLOY_ENV}"
                    echo "ArgoCD will detect changes and deploy automatically"
                }
                failure {
                    echo "❌ Failed to update GitOps repository"
                }
            }
        }

        stage('Tag Application Release') {
            when {
                expression { env.DEPLOY_ENV == 'prod' }
            }
            steps {
                echo '--------- Tagging Application Release ---------'
                script {
                    withCredentials([usernamePassword(credentialsId: 'github-credentials',
                                                      usernameVariable: 'GIT_USERNAME',
                                                      passwordVariable: 'GIT_PASSWORD')]) {
                        sh '''
                            # Configure git
                            git config user.name "${GIT_USER_NAME}"
                            git config user.email "${GIT_USER_EMAIL}"
                            
                            # Create annotated tag
                            git tag -a "${IMAGE_TAG}" -m "Release ${IMAGE_TAG} - Build #${BUILD_NUMBER}" || {
                                echo "Tag ${IMAGE_TAG} already exists locally"
                            }
                            
                            # Build authenticated URL
                            REPO_PATH=$(echo "${GITHUB_REPO_URL}" | sed 's|https://||')
                            AUTHENTICATED_URL="https://${GIT_USERNAME}:${GIT_PASSWORD}@${REPO_PATH}"
                            
                            # Push tag to remote
                            git push "${AUTHENTICATED_URL}" "${IMAGE_TAG}" || {
                                echo "Tag ${IMAGE_TAG} already exists on remote"
                            }
                            
                            echo "Tagged application repo with ${IMAGE_TAG}"
                        '''
                    }
                }
            }
            post {
                success {
                    echo "✅ Application tagged with version ${env.IMAGE_TAG}"
                }
                failure {
                    echo "❌ Failed to tag application release"
                }
            }
        }
    }

    post {
        always {
            script {
                def statusIcon = env.PIPELINE_STATUS == "SUCCESS" ? "✅" : "❌"
                def color = env.PIPELINE_STATUS == "SUCCESS" ? "good" : "danger"
                def slackMessage = env.PIPELINE_STATUS == "SUCCESS" ? 
                    "✅ GitOps update completed! Sync ArgoCD to deploy!" : 
                    "❌ Pipeline failed - check logs for details"
                def finalMessage = [
                    "${statusIcon} GitOps Pipeline *${env.JOB_NAME}* #${env.BUILD_NUMBER} ${env.PIPELINE_STATUS}",
                    "",
                    "*Environment:* ${env.DEPLOY_ENV?.toUpperCase() ?: 'UNKNOWN'}",
                    "*Branch:* ${env.BRANCH_NAME}",
                    "*Docker Image:* ${env.DOCKERHUB_CREDENTIALS_USR}/${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG}",
                    "*GitOps Repo:* GitHub repository updated",
                    "*Deployment:* ArgoCD will sync automatically", 
                    "${slackMessage}"
                ].join('\n')

                slackSend(
                    channel: '#jenkins',
                    color: color,
                    message: finalMessage
                )
            }

            // Report status back to GitHub using Commit Status API
            script {
                def status = env.PIPELINE_STATUS == "SUCCESS" ? "success" : "failure"
                def description = env.PIPELINE_STATUS == "SUCCESS" ? 
                    "Jenkins build passed" : 
                    "Jenkins build failed"
                    
                sh """
                    curl -X POST \
                        -H "Authorization: token \${GITHUB_TOKEN}" \
                        -H "Accept: application/vnd.github.v3+json" \
                        -H "Content-Type: application/json" \
                        -d '{"state":"${status}","target_url":"${BUILD_URL}","description":"${description}","context":"continuous-integration/jenkins"}' \
                        "https://api.github.com/repos/${GITHUB_REPO}/statuses/${env.GIT_COMMIT}"
                """
            }
        }
    }
}