import { createSlice, createAsyncThunk } from '@reduxjs/toolkit'
import { claimBonusXP } from '../../api/quizAPI'

// Use UTC date to ensure tasks rotate at the same time for everyone (UTC Midnight)
const getTodayDate = () => new Date().toISOString().split('T')[0]

const generateDailyTasks = (availableCategories) => {
  // Fallback if no categories provided (shouldn't happen if called correctly)
  const categories = availableCategories && availableCategories.length > 0 
    ? availableCategories 
    : ['DevOps'] 
    
  const randomCategory = categories[Math.floor(Math.random() * categories.length)]
  
  return [
    {
      id: 1,
      type: 'answer_count',
      title: 'Warm Up',
      description: 'Answer 3 questions correctly',
      target: 3,
      progress: 0,
      completed: false,
      claimed: false,
      xpReward: 50,
      icon: 'Zap'
    },
    {
      id: 2,
      type: 'category_answer',
      title: 'Specialist',
      description: `Answer a question in ${randomCategory}`,
      target: 1,
      progress: 0,
      completed: false,
      claimed: false,
      xpReward: 50,
      categoryTarget: randomCategory,
      icon: 'Target'
    },
    {
      id: 3,
      type: 'high_score_hard',
      title: 'Expert Mode',
      description: 'Get 7+ score on a Hard question',
      target: 1,
      progress: 0,
      completed: false,
      claimed: false,
      xpReward: 50,
      icon: 'Trophy'
    }
  ]
}

const loadTasksFromStorage = () => {
  try {
    const stored = localStorage.getItem('quiz_daily_tasks')
    if (!stored) return null
    
    const parsed = JSON.parse(stored)
    const today = getTodayDate()
    
    // Migration: Force update XP rewards to 50 for all tasks
    if (parsed.tasks) {
      parsed.tasks = parsed.tasks.map(t => ({ ...t, xpReward: 50 }))
    }

    // If tasks are from a previous day (or old format), reset tasks but KEEP bonusXP
    if (parsed.lastUpdated !== today) {
      return {
        lastUpdated: today,
        tasks: [], // Will be regenerated by initializeTasks
        bonusXP: parsed.bonusXP || 0
      }
    }

    return parsed
  } catch (e) {
    return null
  }
}

const initialState = loadTasksFromStorage() || {
  lastUpdated: getTodayDate(),
  tasks: [], // Start empty, wait for categories to be fetched
  bonusXP: 0 // XP claimed from tasks
}

const tasksSlice = createSlice({
  name: 'tasks',
  initialState,
  reducers: {
    initializeTasks: (state, action) => {
      const categories = action.payload
      const today = getTodayDate()
      
      // If we already have tasks for today, don't overwrite them
      if (state.lastUpdated === today && state.tasks.length > 0) {
        return
      }

      // If we don't have categories, we can't generate the "Specialist" task properly
      if (!categories || categories.length === 0) {
        return
      }

      state.lastUpdated = today
      state.tasks = generateDailyTasks(categories)
      localStorage.setItem('quiz_daily_tasks', JSON.stringify(state))
    },
    updateTaskProgress: (state, action) => {
      const { category, difficulty, score } = action.payload
      let changed = false

      state.tasks.forEach(task => {
        if (task.completed) return

        if (task.type === 'answer_count') {
          task.progress += 1
          if (task.progress >= task.target) {
            task.progress = task.target
            task.completed = true
          }
          changed = true
        } else if (task.type === 'category_answer') {
          if (category === task.categoryTarget) {
            task.progress += 1
            if (task.progress >= task.target) {
              task.progress = task.target
              task.completed = true
            }
            changed = true
          }
        } else if (task.type === 'high_score_hard') {
          // Difficulty 3 is Hard (assuming 1=Easy, 2=Medium, 3=Hard)
          // Score check: handle "8/10" string or number 8
          let numericScore = score
          if (typeof score === 'string' && score.includes('/')) {
            numericScore = parseFloat(score.split('/')[0])
          }
          
          if (difficulty === 3 && numericScore >= 7) {
            task.progress += 1
            if (task.progress >= task.target) {
              task.progress = task.target
              task.completed = true
            }
            changed = true
          }
        }
      })

      if (changed) {
        localStorage.setItem('quiz_daily_tasks', JSON.stringify(state))
      }
    },
    markTaskClaimed: (state, action) => {
      const task = state.tasks.find(t => t.id === action.payload)
      if (task && task.completed && !task.claimed) {
        task.claimed = true
        state.bonusXP += task.xpReward
        localStorage.setItem('quiz_daily_tasks', JSON.stringify(state))
      }
    },
  },
})

// Async thunk to claim reward and update backend
export const claimReward = createAsyncThunk(
  'tasks/claimReward',
  async (taskId, { getState, dispatch }) => {
    const state = getState()
    const task = state.tasks.tasks.find(t => t.id === taskId)
    
    if (!task || !task.completed || task.claimed) {
      throw new Error('Task cannot be claimed')
    }
    
    // Call backend to add XP
    const result = await claimBonusXP(task.xpReward, 'daily_mission')
    
    if (result.success) {
      // Update local state after successful backend call
      dispatch(markTaskClaimed(taskId))
      return { taskId, xp: task.xpReward }
    } else {
      throw new Error('Failed to claim XP from server')
    }
  }
)

export const { initializeTasks, updateTaskProgress, markTaskClaimed } = tasksSlice.actions

export const selectDailyTasks = (state) => state.tasks.tasks
export const selectBonusXP = (state) => state.tasks.bonusXP

export default tasksSlice.reducer
